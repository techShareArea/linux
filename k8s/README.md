#### k8s引入pod的概念，而不直接操作docker容器的原因
```
1. k8s借助CRI抽象层，使得k8s不依赖于底层某一种具体的容器，而是直接操作Pod，Pod内部再管理多个业务上紧密相关的用户业务容器，便于k8s做扩展；
2. 假设k8s不引入Pod，使k8s直接管理容器，一组容器作为一个单元，如果其中一个容器死了，会存在这个单元的状态如何去定义，应该理解为整体死亡，还是个体死亡；k8s有个机制:每个Pod里都有一个k8s系统自带的pause容器，通过引入pause这个与业务无关，并且作用类似于linux系统守护进程的k8s系统标准容器，以pause容器的状态来代表整个容器组的状态；
3. pod里面所有的业务容器共享pause容器的IP地址，以及pause容器mount的volume，通过这种设计，业务容器之间可以直接通信，文件也能直接彼此共享。
```












