### 前言

free命令显示系统内存的使用情况，包括物理内存，虚拟的文件交换内存(swap)，共享内存区段，以及系统内核缓冲区的内存。

### free命令详解

#### 语法
> free [-bkmotV] [-s <间隔秒数>]        

#### 参数说明
- -b: 以Byte为单位显示内存使用情况      
- -k: 以KB为单位显示内存使用情况        
- -m: 以MB为单位显示内存使用情况        
- -h: 以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值 
- -s<间隔秒数>: 持续观察内存使用状况            
- -t: 显示内存总和列       
- -V: 显示版本信息        

#### 示例说明
> [root@cangqiong ~]# free -h       

```
              total        used        free      shared  buff/cache   available
Mem:           1.8G        221M        405M        572K        1.2G        1.4G
Swap:            0B          0B          0B
```
```
total列显示系统总的可用物理内存和交换空间大小;
used列显示已经被使用的物理内存和交换空间;
free列显示还有多少物理内存和交换空间可用使用;
shared列显示被共享使用的物理内存大小;       
buff/cache列显示被buffer和cache使用的物理内存大小;
available列显示还可以被应用程序使用的物理内存大小。
```

#### 核心知识点:buff/cache

##### buffer
buffer在操作系统中指buffer cache，中文一般翻译为 "缓冲区"。要理解缓冲区，必须明确另外两个概念："扇区"和"块"。扇区是设备的最小寻址单元，也叫"硬扇区"或"设备块"。块是操作系统中文件系统的最小寻址单元，也叫"文件块"或"I/O块"。每个块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示。        
注:可参考扇区与缓冲区之间的关系图       
另注:buffer cache只有块的概念而没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟存放的是什么格式的文件。      

##### cache
cache在操作系统中指page cache，中文一般翻译为"页高速缓存"。页高速缓存是内核实现的磁盘缓存。它主要用来减少对磁盘的I/O操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。页高速缓存缓存的是内存页面。缓存中的页来自对普通文件、块设备文件(这个指的就是buffer cache)和内存映射文件的读写。页高速缓存对普通文件的缓存，我们可以这样理解：当内核要读一个文件(比如:/etc/hosts)时，它会先检查这个文件的数据是不是已经在页高速缓存中了。如果在，就放弃访问磁盘，直接从内存中读取。这个行为称为缓存命中。如果数据不在缓存中，就是未命中缓存，此时内核就要调度块I/O操作从磁盘去读取数据。然后内核将读来的数据放入页高速缓存中。这种缓存的目标是文件系统可以识别的文件(比如:/etc/hosts)。页高速缓存对块设备文件的缓存就是我们在前面介绍的buffer cahce。因为独立的磁盘块通过缓冲区也被存入了页高速缓存(缓冲区最终是由页高速缓存来承载的)。       
无论是缓冲区还是页高速缓存，它们的实现方式都是一样的。缓冲区只不过是一种概念上比较特殊的页高速缓存罢了。

##### free与available        
free是真正尚未被使用的物理内存数量。至于available就比较有意思了，它是从应用程序的角度看到的可用内存数量。Linux内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的buffer和cache。所以对于内核来说，buffer和cache都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的free内存可以用，内核就会从buffer和cache中回收内存来满足应用程序的请求。所以从应用程序的角度来说，available=free+buffer+cache。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。

##### 交换空间(swap space)
swap space是磁盘上的一块区域，可以是一个分区，也可以是一个文件。所以具体的实现可以是swap分区也可以是swap文件。当系统物理内存吃紧时，Linux会将内存中不常访问的数据保存到swap上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问swap上存储的内容时，再将swap上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。      
现在的机器一般都不太缺内存，如果系统默认还是使用了swap是不是会拖累系统的性能？理论上是的，但实际上可能性并不是很大。并且内核提供了一个叫做swappiness的参数，用于配置需要将内存中不常用的数据移到swap中去的紧迫程度。这个参数的取值范围是0～100，0告诉内核尽可能的不要将内存数据移到swap中，也即只有在迫不得已的情况下才这么做，而100告诉内核只要有可能，尽量的将内存中不常访问的数据移到swap中。在ubuntu系统中，swappiness的默认值是60。如果我们觉着内存充足，可以在/etc/sysctl.conf文件中设置swappiness：
> vm.swappiness=10      

